
import "https://deno.land/x/xhr@0.1.0/mod.ts";
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.7.1'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type, x-app-name, x-auth-token, x-skip-auth',
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
};

const SUPABASE_URL = Deno.env.get('SUPABASE_URL')!;
const SUPABASE_ANON_KEY = Deno.env.get('SUPABASE_ANON_KEY')!;
const OPENAI_API_KEY = Deno.env.get('OPENAI_API_KEY');

const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

console.log("üîç UNIFIED AI BRAIN: Function loaded with optimized voice translation and instant TTS");

serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    console.log("üîç UNIFIED AI BRAIN: Processing request with optimized TTS");
    
    const contentType = req.headers.get('content-type') || '';
    
    // Handle voice translation with audio blob (FormData)
    if (contentType.includes('multipart/form-data')) {
      console.log("üé§ VOICE TRANSLATION: Processing audio blob with auto-TTS");
      return await processVoiceTranslationWithAutoTTS(req);
    }
    
    // Handle TTS-only requests (JSON)
    const requestBody = await req.json();
    
    if (requestBody.requestType === 'tts' || requestBody.text) {
      console.log("üîä TTS REQUEST DETECTED:", requestBody.voice || 'alloy', "Body:", JSON.stringify(requestBody, null, 2));
      return await processTTSOptimized(requestBody);
    }

    // For any other request type, return error
    return new Response(JSON.stringify({
      error: 'Invalid request type. This function handles voice translation and TTS only.',
      success: false
    }), {
      status: 400,
      headers: { ...corsHeaders, "Content-Type": "application/json" }
    });

  } catch (error) {
    console.error("üö® UNIFIED AI BRAIN: Critical Error:", error);
    return new Response(JSON.stringify({
      error: error.message || 'Processing error',
      success: false
    }), {
      status: 500,
      headers: { ...corsHeaders, "Content-Type": "application/json" }
    });
  }
});

// OPTIMIZED: Voice translation with automatic TTS generation
async function processVoiceTranslationWithAutoTTS(req: Request) {
  try {
    console.log("üé§ VOICE TRANSLATION: Starting optimized processing");
    
    const formData = await req.formData();
    const audioBlob = formData.get('audioBlob') as File;
    const targetLanguage = formData.get('targetLanguage') as string || 'en';
    const autoPlayEnabled = formData.get('autoPlayEnabled') === 'true';
    
    if (!audioBlob) {
      throw new Error('No audio blob provided');
    }

    console.log("üé§ Processing audio blob:", audioBlob.size, "bytes for language:", targetLanguage);

    // Step 1: Transcribe audio using Whisper
    const audioBuffer = await audioBlob.arrayBuffer();
    const transcriptionResult = await transcribeWithWhisper(audioBuffer);
    
    if (!transcriptionResult.success) {
      throw new Error(transcriptionResult.error || 'Transcription failed');
    }

    const originalText = transcriptionResult.text;
    console.log("üé§ Transcribed text:", originalText);

    // Step 2: Translate if needed
    let translatedText = originalText;
    let sourceLanguage = transcriptionResult.language || 'auto';
    
    if (targetLanguage !== 'auto' && sourceLanguage !== targetLanguage) {
      const translationResult = await translateText(originalText, sourceLanguage, targetLanguage);
      if (translationResult.success) {
        translatedText = translationResult.translatedText;
        console.log("üé§ Translated to:", translatedText);
      }
    }

    // Step 3: AUTOMATICALLY generate TTS for instant playback
    let autoGeneratedTTS = null;
    if (translatedText) {
      console.log("üîä AUTO-GENERATING TTS for instant playback");
      try {
        const ttsResult = await generateTTSInstantly(translatedText, targetLanguage);
        if (ttsResult.success) {
          autoGeneratedTTS = {
            audioContent: ttsResult.audioContent,
            size: ttsResult.size || 0
          };
          console.log("üîä TTS auto-generated successfully for instant playback");
        }
      } catch (ttsError) {
        console.error("üîä Auto-TTS generation failed (non-blocking):", ttsError);
      }
    }

    // Return structured response with auto-generated TTS
    const response = {
      success: true,
      originalText,
      translatedText,
      sourceLanguage,
      targetLanguage,
      autoGeneratedTTS, // Pre-generated for instant playback
      autoPlayEnabled,
      processingTime: Date.now()
    };

    console.log("üé§ VOICE TRANSLATION: Completed with auto-TTS");
    return new Response(JSON.stringify(response), {
      headers: { ...corsHeaders, "Content-Type": "application/json" }
    });

  } catch (error) {
    console.error("üé§ VOICE TRANSLATION ERROR:", error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message || 'Voice translation failed'
    }), {
      status: 500,
      headers: { ...corsHeaders, "Content-Type": "application/json" }
    });
  }
}

// OPTIMIZED: Single TTS function with no recursion
async function processTTSOptimized(requestBody: any) {
  try {
    console.log("üîä OPTIMIZED TTS: Processing instant text-to-speech for user:", requestBody.userId || 'unknown');
    
    const text = requestBody.text;
    const voice = requestBody.voice || 'alloy';
    const language = requestBody.language || 'en';
    
    if (!text) {
      throw new Error('No text provided for TTS');
    }

    console.log(`üîä OPTIMIZED TTS: Generating instant speech for text: "${text.substring(0, 100)}..."`);
    
    const ttsResult = await generateTTSInstantly(text, language, voice);
    
    if (!ttsResult.success) {
      throw new Error(ttsResult.error || 'TTS generation failed');
    }

    console.log("üîä OPTIMIZED TTS: Generated successfully, size:", ttsResult.size || 0, "bytes");

    return new Response(JSON.stringify({
      success: true,
      audioContent: ttsResult.audioContent,
      size: ttsResult.size || 0,
      voice,
      language,
      text: text.substring(0, 100)
    }), {
      headers: { ...corsHeaders, "Content-Type": "application/json" }
    });

  } catch (error) {
    console.error("üîä OPTIMIZED TTS: Error:", error);
    return new Response(JSON.stringify({
      success: false,
      error: error.message || 'TTS processing failed'
    }), {
      status: 500,
      headers: { ...corsHeaders, "Content-Type": "application/json" }
    });
  }
}

// FAST: Generate TTS instantly with OpenAI
async function generateTTSInstantly(text: string, language: string = 'en', voice: string = 'alloy'): Promise<any> {
  try {
    if (!OPENAI_API_KEY) {
      throw new Error('OpenAI API key not configured');
    }

    console.log("üîä TTS: Calling OpenAI TTS API directly");
    
    const response = await fetch('https://api.openai.com/v1/audio/speech', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${OPENAI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'tts-1-hd',
        input: text.substring(0, 4000), // Limit text length
        voice: voice,
        response_format: 'mp3'
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error("üîä TTS: OpenAI API error:", response.status, errorText);
      throw new Error(`OpenAI TTS API error: ${response.status}`);
    }

    const audioBuffer = await response.arrayBuffer();
    const audioContent = btoa(String.fromCharCode(...new Uint8Array(audioBuffer)));
    
    console.log("üîä TTS: Generated audio successfully, size:", audioBuffer.byteLength, "bytes");

    return {
      success: true,
      audioContent,
      size: audioBuffer.byteLength
    };

  } catch (error) {
    console.error("üîä TTS: Generation error:", error);
    return {
      success: false,
      error: error.message
    };
  }
}

// Helper: Transcribe audio with Whisper
async function transcribeWithWhisper(audioBuffer: ArrayBuffer): Promise<any> {
  try {
    if (!OPENAI_API_KEY) {
      throw new Error('OpenAI API key not configured');
    }

    const formData = new FormData();
    const audioBlob = new Blob([audioBuffer], { type: 'audio/webm' });
    formData.append('file', audioBlob, 'audio.webm');
    formData.append('model', 'whisper-1');
    formData.append('response_format', 'verbose_json');

    const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${OPENAI_API_KEY}`,
      },
      body: formData,
    });

    if (!response.ok) {
      throw new Error(`Whisper API error: ${response.status}`);
    }

    const result = await response.json();
    
    return {
      success: true,
      text: result.text,
      language: result.language || 'en'
    };

  } catch (error) {
    console.error("üé§ Whisper transcription error:", error);
    return {
      success: false,
      error: error.message
    };
  }
}

// Helper: Translate text
async function translateText(text: string, sourceLanguage: string, targetLanguage: string): Promise<any> {
  try {
    if (!OPENAI_API_KEY) {
      throw new Error('OpenAI API key not configured');
    }

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${OPENAI_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'system',
            content: `Translate the following text from ${sourceLanguage} to ${targetLanguage}. Return only the translation, nothing else.`
          },
          {
            role: 'user',
            content: text
          }
        ],
        max_tokens: 1000,
        temperature: 0.1
      }),
    });

    if (!response.ok) {
      throw new Error(`Translation API error: ${response.status}`);
    }

    const result = await response.json();
    const translatedText = result.choices[0]?.message?.content?.trim();

    if (!translatedText) {
      throw new Error('No translation received');
    }

    return {
      success: true,
      translatedText
    };

  } catch (error) {
    console.error("üåç Translation error:", error);
    return {
      success: false,
      error: error.message
    };
  }
}
